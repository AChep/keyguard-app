package com.artemchep.dbus.notification

import org.freedesktop.dbus.annotations.DBusInterfaceName
import org.freedesktop.dbus.annotations.DBusMemberName
import org.freedesktop.dbus.connections.impl.DBusConnectionBuilder
import org.freedesktop.dbus.interfaces.DBusInterface
import org.freedesktop.dbus.types.UInt32
import org.freedesktop.dbus.types.Variant
import kotlin.uuid.ExperimentalUuidApi
import kotlin.uuid.Uuid

@OptIn(ExperimentalUuidApi::class)
internal fun postNotificationDbus(
    id: Int = 0,
    title: String,
    text: String,
): Int? {
    // 1. Portal
    val portalResult = run {
        val notificationIdPrefix = "post:"
        val notificationIdSuffix = Uuid.random().toString()
        val id = notificationIdPrefix + notificationIdSuffix
        postNotificationPortal(id, title, text)
            ?.hashCode()
    }
    if (portalResult != null) return portalResult

    // 2. Fallback to legacy
    return postNotificationLegacy(id, title, text)
}

//
// Portal
//

@OptIn(ExperimentalUuidApi::class)
private fun postNotificationPortal(
    id: String,
    title: String,
    text: String,
): String? = runCatching {
    DBusConnectionBuilder.forSessionBus().build().use { conn ->
        val notifications: NotificationsPortal = conn.getRemoteObject(
            "org.freedesktop.portal.Desktop",
            "/org/freedesktop/portal/desktop",
            NotificationsPortal::class.java,
        )

        val options = HashMap<String, Variant<*>>()
        options["title"] = Variant(title)
        options["body"] = Variant(text)
        options["priority"] = Variant("high")

        // Portals use String IDs generated by the client.
        // We map the integer input to a string key.
        options["id"] = Variant(id)

        notifications.AddNotification("", options)
        id
    }
}.getOrElse {
    null
}

@DBusInterfaceName("org.freedesktop.portal.Notification")
internal interface NotificationsPortal : DBusInterface {
    @Suppress("FunctionName")
    @DBusMemberName("AddNotification")
    fun AddNotification(parent_window: String, notification: Map<String, Variant<*>>)
}

//
// Legacy
//

private fun postNotificationLegacy(
    id: Int,
    title: String,
    text: String,
): Int? = runCatching {
    DBusConnectionBuilder.forSessionBus().build().use { conn ->
        val notifications: NotificationsLegacy = conn.getRemoteObject(
            "org.freedesktop.Notifications",
            "/org/freedesktop/Notifications",
            NotificationsLegacy::class.java,
        )

        val hints = mutableMapOf<String, Variant<Byte>>()
        hints["urgency"] = Variant(2) // 2 = Critical

        val resultId = notifications.Notify(
            "Keyguard",
            // The optional notification ID that this notification replaces. The server must
            // atomically (ie with no flicker or other visual cues) replace the given
            // notification with this one. This allows clients to effectively modify the
            // notification while it's active. A value of value of 0 means that this
            // notification won't replace any existing notifications.
            UInt32(id.toLong()),
            "",
            title,
            text,
            arrayOf(),
            hints,
            0,
        )
        resultId.toInt()
    }
}.getOrElse { e ->
    e.printStackTrace()
    null
}

@DBusInterfaceName("org.freedesktop.Notifications")
internal interface NotificationsLegacy : DBusInterface {
    @Suppress("FunctionName")
    @DBusMemberName("Notify")
    fun Notify(
        appName: String,
        replacesId: UInt32,
        appIcon: String,
        summary: String,
        body: String,
        actions: Array<String>,
        hints: MutableMap<String, Variant<Byte>>,
        timeout: Int,
    ): UInt32
}
